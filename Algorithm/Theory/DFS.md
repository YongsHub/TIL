# DFS

[참고 내용 링크](https://youtube.com/playlist?list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC)<br>
Depth-First-Search, 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. DFS를 설명하기 이전, 그래프의 기본 구조에 대해 공부하는 것이 좋다.

## 📌 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩 테스트에서는 이 두방식 모두 필요하니 두 개념에 대해 바르게 이해해야 한다.

- 인접 행렬: 2차원 배열로 그래프의 연결 관계를 표현하는 방식
- 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

## 🎈 인접 행렬

- 파이썬에서는 리스트 자료형으로 표현할 수 있으므로 파이썬은 인접 행렬을 리스트로 구현한다.

> 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다. 실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값 중에서 999999999 등의 값으로 초기화하는 경우가 많다. 이렇게 그래프를 인접 행렬 방식으로 처리할 때는 다음과 같이 데이터를 초기화한다.

![그래프](./img/graph_ex.jpeg)

```
INF = 999999999 # 무한의 비용 선언
# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]
print(graph)
```

## 🎈 인접 리스트

> 인접 리스트 방식에서는 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.

인접 리스트는 '연결 리스트'라는 자료구조를 이용해 구현하는데, C++나 자바와 같은 프로그래밍 언어에서는 별도로 연결 리스트 기능을 위한 표준 라이브러리를 제공한다.

But, 파이썬은 기본 자료형인 리스트 자료형이 append()와 메소드를 제공하므로, 전통적인 프로그래밍 언어에서의 배열과 연결 리스트의 기능을 모두 기본으로 제공함.

- 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 된다는 점만 기억하자.

```
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
```

## 이 두 방식의 차이를 알아보자

코딩 테스트를 위해 메모리와 속도 측면에서 살펴보는 것이 좋다. 메모리 측면에서 인접 행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면에 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다. 이러한 특징 때문에 인접 리스트 방식은 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. 인접 리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.

ex) 노드 1과 노드 7이 연결되어 있는 상황을 생각해볼 때, 인접 행렬에서는 graph[1][7]만을 확인하면 되지만 인접 리스트 방식에서는 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인해야한다.

<span style="color:yellow"> DFS 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다.</span>

## 📌 방식

- 1)탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
- 2)스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
- 3)2번의 과정을 더이상 수행할 수 없을 때까지 반복한다.

## 🎈 DFS 예제

```
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end= ' ')
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

visited = [False] * 9

dfs(graph, 1, visited)
```

# DFS 실전문제

[유사문제 풀어보기](https://www.acmicpc.net/problem/4963)

N \_ M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이 때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 다음의 4 \* 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다.

![문제 사진](./img/DFS.jpeg)

## 📌 위의 그래프인 경우 입력 예시

```
4 5
00110
00011
11111
00000
```

## ❗️ 입력 조건

- 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다.(1 <= N, M <= 1000)
- 두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.
- 이 때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

## ❗️ 출력 조건

- 한 번에 만들 수 있는 아이스크림의 개수를 출력 한다.

## 정답 코드

```
n, m = map(int, input().split())
arr = [[0] * m for i in range(n)]

for i in range(len(arr)):
  arr[i] = list(map(int, input()))


def dfs(x, y):
  if x < 0 or y < 0 or x >= n or y >= m:
    return False

  if arr[x][y] != 0: # 1이라면 False
    return False
  else:
    arr[x][y] = 1 # 방문했다는 의미로 1로 만들어준다.
    dfs(x - 1, y) # 상
    dfs(x + 1, y) # 하
    dfs(x, y - 1) # 좌
    dfs(x, y + 1) # 우
    return True


result = 0

for i in range(n):
  for j in range(m):
    if dfs(i, j) == True:
      result += 1

print(result)
```
