## AOP

AOP? 스프링의 3대 핵심 기술 중 하나이다.
스프링의 기술 중, 가장 이해하기 힘든 난해한 용어와 개념을 가진 기술이다.
AOP를 바르게 이용하려면 필연적인 등장배경과 스프링이 그것을 도입한 이유, 적용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 필요함

**스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다**
서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을 AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔볼 수 있음

더하여, 과정 속에 AOP를 도입해야 했던 이유도 알아봐야 한다.

비즈니스 로직이 주인이어야 할 메소드 안에 이름도 길고 트랜잭션 코드가 더 많은 자리를 차지하는 모습이 별로다.

따라서, 한 번에 두 개의 Service Interface 구현 클래스를 동시에 이용하면 어떨까?
지금 해결하려고 하는 문제는 Service에는 순수하게 비즈니스 로직을 담고 있는 코드만 놔두고 트랜잭션 경계설정을 담당하는 코드를 외부로 빼내려는 것. 하지만 클라이언트가 Service의 기능을 제대로 이용하려면 트랜잭션이 적용돼야 함.

따라서 Trasaction 설정만 해주는 ServiceTx를 구현하여 비즈니스 로직을 담은 Service를 DI하여 구현하는 방법이 존재함.

---

스프링의 테스트용 컨텍스트에서 가져올 빈들을 생각해보자. 기존에는 Service 클래스 타입의 빈을 @Autowired로 가져다가 사용했음. 하지만 Service는 이제 인터페이스로 바뀌었음. 인터페이스라고 하더라도 Autowired로 가져오는데 아무런 문제가 없음.
인터페이스 타입을 가진 두 개의 빈이 존재한다면 기본적으로 하나의 빈을 결정할 수 없을때는 필드 이름을 이용해 빈을 찾음

결과적으로 UserService는 인터페이스로 변경했으므로 테스트 코드는 이제 구체적인 정보는 알지 못한 채 -> 컨테이너가 제공해주는 대표적인 UserService 구현 오브젝트를 사용함

---

가장 편하고 좋은 테스트 방법 -> 가능한 한 작은 단위로 쪼개서 테스트

클래스 하나가 동작하도록 테스트를 만드는 것과 클래스 수십 개가 얽히고 섥혀서 동작하도록 만드는 것 중에서 어던 것이 논리적인 오류를 착기 쉬울지는 분명함.
하지만 그럴 수 없는 경우가 많음 -> 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 단위의 테스트가 주는 장점을 얻기 힘들다.

따라서, 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 방법이 존재함.

단위테스트의 단위는 정하기 나름이겠지만 -> 고립시키는 것을 명칭해보자
